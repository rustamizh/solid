# SOLID

> на основе ресурса [https://ota-solid.vercel.app/](https://ota-solid.vercel.app/)

- [Single Responsibility Principle (SRP)](#single-responsibility-principle)
- [Open-Closed Principle (OCP)](#open-closed-principle)
- [Liskov Substitution Principle (LSP)](#liskov-substitution-principle)
- [Interface Segregation Principle (ISP)](#interface-segregation-principle)
- [Dependency Inversion Principle (DIP)](#dependency-inversion-principle)

## <a name="single-responsibility-principle"></a>Single Responsibility Principle  

### Описание
Принцип единственной ответственности (Single Responsibility Principle, SRP) означает, что у модуля должна быть только одна причина для изменения. Весь код, который меняется по этой причине, должен быть собран в этом модуле.

Проще говоря принцип предлагает нам проводить границы между модулями так, чтобы изменение в бизнес-правилах затрагивало как можно меньше модулей, в идеале — один.

Основной инструмент принципа — объединять те части, которые меняются по одной причине, и разделять те, которые меняются по разным.

Принцип позволяет уменьшить количество кода, который нужно менять при изменении бизнес-правил. Он помогает ограничить влияние этих изменений и контролировать сложность программы.

### Коротко
Принцип единственной ответственности:
- помогает разбивать и декомпозировать задачи по одной на модуль;
- уменьшает количество модулей, которые надо изменить при изменении требований;
- ограничивает влияние изменений, помогая контролировать сложность системы.

### Шаблоны проектирования и приёмы рефакторинга

**Выделение класса**

Выделение класса — приём рефакторинга, при котором из большого класса с множеством слабо-связанных по смыслу полей и методов, выделяется один или несколько классов.

Смысл приёма в том, чтобы явно выделить назначение класса. Идеальный результат — получить класс, который можно описать одной фразой или даже одним словом.

**Фасад**

Фасад — шаблон проектирования, при котором сложная логика скрывается за вызовом более простого API.

Фасад обеспечивает простое общение со сложной частью системы, беря ответственность за настройку и вызов специфических методов конкретных объектов на себя.

Один из минусов фасада в том, что он может превратиться в божественный объект.

**Прокси**

Прокси — шаблон проектирования, при котором общение с каким-то объектом контролирует другой объект-заместитель (прокси). Он позволяет расширять функциональность существующих классов, не меняя их.

### Антипаттерны и запахи
Существуют и антипаттерны, которые или сами нарушают SRP, или усложняют следование принципу.

**Божественный объект**

Божественный объект — это сущность, которая отвечает за слишком много.

Проблема таких объектов в том, что внутри них скапливается неоправданно большое количество данных. Со временем может случиться, что никакое действие нельзя будет сделать без участия божественного объекта.

Это затрудняет рефакторинг, тестирование и внесение изолированных изменений в код.

**Синглтон**

Синглтон — это паттерн, при котором в приложении существует только один экземпляр какого-то класса. Существующий синглтон гарантирует, что все новые созданные объекты будут ссылаться на него.

С точки зрения SRP это смешение ответственностей. Потому что синглтон не только выполняет свою основную функцию, но ещё и проверяет, не существует ли уже созданных экземпляров.

Проблем у этого паттерна несколько:
- он глобален — когда нарушается инкапсуляция состояния, повышается вероятность непредсказуемых нежелательных изменений;
- излишне имплицитен — трудно заранее понять, как себя поведёт объект в какой-то ситуации;
- трудно тестируется — глобальный объект хранит большое количество данных и может находиться в большом количестве различных состояний, из-за чего модульные тесты могут показывать непредсказуемые результаты.

**Смешение архитектурных слоёв**

Паттерн MVC подразумевает три сущности: модель, представление и контроллер. Модель отвечает за хранение данных; представление — за их отображение; контроллер — за преобразование и обработку.

Смешение слоёв — это неправильное распределение или размазывание ответственностей между слоями. Оно может приводить:
- к разрастанию контроллера, что делает его код трудным для понимания;
- появлению логики внутри модели, что затрудняет переиспользование модели.

### Ограничения и подводные камни
У каждого принципа есть ограничения и область применения. Для SRP характерны следующие ограничения и подводные камни.

**Слепое следование опасно**

Слепое следование принципу (например, преждевременная оптимизация) может создать лишние абстракции и сделать программу чрезмерно сложной. Использовать SRP стоит тогда, когда вносить изменения в класс, нарушающий его, становится дорого.

**Трудность начального проектирования**

Выделить зоны ответственности сущностей при первичном проектировании иногда бывает трудно. Взаимодействие сущностей может быть неочевидным, из-за чего проектировщикам может быть трудно определиться с методами классов. В этом случае могут помочь прототипирование и диаграммное моделирование (UML, DFD, ERD, IDEF).

**Разработка через тестирование — не панацея, а инструмент**

Считается, что разработка через тестирование (TDD) может помочь выделить в классах необходимые методы, но это тоже помогает не всегда. TDD определённо показывает, каким будет видеть наше API пользователь, но он не всегда помогает выделить зоны ответственности модулей.

## <a name="open-closed-principle"></a>Open-Closed Principle

### Описание

Принцип открытости-закрытости (Open-Closed Principle, OCP) помогает исключить такую проблему. Согласно ему модули должны быть открыты для расширения, но закрыты для изменения.

Простыми словами — модули надо проектировать так, чтобы их нельзя было менять, а новая функциональность должна появляться лишь с помощью создания новых сущностей и композиции их со старыми.

Основная цель принципа — помочь разработать проект, устойчивый к изменениям, срок жизни которых превышает срок существования первой версии проекта.

Модули, которые удовлетворяют OCP:

- открыты для расширения — их функциональность может быть дополнена с помощью других модулей, если изменятся требования;
- закрыты для изменения — расширение функциональности модуля не должно приводить к изменениям в модулях, которые его используют.

Конечно, всегда есть изменения, которые невозможно внести, не изменив код какого-то модуля — никакая система не может быть закрыта на 100%. Поэтому при проектировании важен стратегический подход. Необходимо определить, от каких именно изменений и какие именно модули вы хотите закрыть. Это решение следует принимать опираясь на опыт, а также знания предметной области и пользователей системы.

Нарушение принципа открытости-закрытости приводит к ситуациям, когда изменение в одном модуле вынуждает менять другие, связанные с ним. Это в свою очередь нарушает SRP, потому что весь код, который меняется по какой-то одной причине, должен быть собран в одном модуле. (Разные модули — разные причины для изменения.)

### Коротко
Принцип открытости-закрытости:
- заставляет проектировать модули так, чтобы они делали только одну вещь и делали её хорошо;
- побуждает связывать сущности через абстракции (а не реализацию) там, где могут поменяться бизнес-требования;
- обращает внимание проектировщиков на места стыка и взаимодействие сущностей;
- позволяет сократить количество кода, который необходимо менять при изменении бизнес-требований;
- делает внесение изменений безопасным и относительно дешёвым.

### Шаблоны проектирования и приёмы рефакторинга

**Абстрактная фабрика**

Фабрика — это сущность, которая создаёт другие сущности по заданным правилам, например, создаёт экземпляры классов или объекты.

Абстрактная фабрика — это фабрика, которая создаёт фабрики.

Этот шаблон позволяет создавать сущности без привязки к конкретным классам — то есть без привязки к реализации. Так добавление новых типов сущностей изменяет минимальное количество модулей.

**Стратегия**

В прошлом примере мы избавились от необходимости менять код форматеров при добавлении новых требований. Но вы могли заметить, что в методе configure класса AppConfigurator есть условие, которое проверяет тип формата для отчёта.

По-хорошему, подобные условия следует заменять на динамический выбор нужных сущностей. С этим может помочь ещё один шаблон — стратегия.

Этот шаблон позволяет менять настройки, конфигурацию или алгоритм в зависимости от ситуации и требований.

**Декоратор**

Декоратор — это шаблон, который заключается в создании обёрток с дополнительной функциональностью для объектов. Такие обёртки позволяют не изменять сам объект, но при этом расширять его функциональность.

Отличие декоратора от наследования в возможности расширять функциональность динамически, без необходимости описывать каждый класс-наследник отдельно.

**Наблюдатель**

Наблюдатель — шаблон, который создаёт механизм подписки, когда некоторые сущности могут реагировать на поведение других.

Этот шаблон позволяет добавлять новых наблюдателей без необходимости менять код наблюдаемого объекта.

**Замена прямого наследования на полиморфизм и композицию**

Модули, зависящие от конкретных классов, связаны с ними слишком сильно, из-за чего изменение в одном модуле затронет изменение в другом.

Замена прямого наследования на полиморфизм или композицию — это приём рефакторинга, который ослабляет зацепление модулей через введение абстракций: интерфейсов, обёрток и т. д.

### Антипаттерны и запахи
Все паттерны, которые так или иначе теснее связывают сущности между собой, можно назвать антипаттернами.

**Связывание через конкретные классы**

Проблемы связывания через конкретные классы мы рассмотрели в примере из раздела «В идеальном мире». Класс AreaCalculator изначально зависел от конкретного класса Rectangle, из-за чего при изменении требований, приходилось обновлять код этого класса.

Когда мы ввели прослойку в виде интерфейса Shape, класс AreaCalculator начинал зависеть от интерфейса, а не от конкретных классов, изменение в требованиях перестало затрагивать код класса AreaCalculator.

**Синглтон**

Синглтон — это паттерн, при котором в приложении существует только один экземпляр какого-то класса. Существующий синглтон гарантирует, что все новые созданные объекты будут ссылаться на него.

Если синглтон содержит в себе общее состояние или глобальные переменные, либо сам является глобальной сущностью, то зацепление объектов с ним чрезмерно высокое.

Это может приводить к ситуациям, когда при изменении требований приходится менять и сам синглтон, и все объекты, которые с ним связаны.

Синглтон можно использовать и без высокого зацепления модулей (применяя, например, абстрактные интерфейсы), но это значительно усложняет структуру проекта.

**Легковес**

Легковес — шаблон, который уменьшает расход памяти, держа общее состояние объектов внутри себя, вместо хранения одинаковых данных в каждом объекте.

Его проблема с точки зрения OCP в том же высоком связывании модулей. Если сущность выступает в роли общего контекста для нескольких объектов, при изменении требований придётся менять код каждого модуля.

Как и в случае с синглтоном, с легковесом можно работать без высокого зацепления, но это также будет увеличивать сложность.

### Ограничения и подводные камни

У каждого принципа есть ограничения и область применения. Для OCP характерны следующие ограничения и подводные камни.

**Система не может быть закрыта на 100%**

Всегда есть изменения, которые невозможно внести, не изменив код какого-то модуля, поэтому при проектировании важен стратегический подход. Необходимо определить, от каких именно изменений и какие именно модули вы хотите закрыть.

Следует учитывать, что люди очень плохо умеют прогнозировать изменения. Даже имея достаточно знаний о системе и опыта, проектировщики не могут быть уверены, что предусмотрели все возможные варианты развития системы.

OCP предлагает подход Just-in-time design, при котором новые сущности добавляются в систему по мере необходимости, но не раньше. Это чем-то похоже на отказ от ранней оптимизации и раннего добавления абстракций.

Цель подхода в том, чтобы не создавать абстракции на пустом месте. Один из критериев хорошего дизайна — простота, поэтому использовать OCP следует всегда с оглядкой на то, насколько система получится простой в итоге.

**Большое количество сущностей**

Добавление функциональности менее рискованно, чем изменение существующей, но взамен мы рискуем увеличить количество сущностей. Бесконтрольное и бездумное следование OCP может приводить к ситуациям, когда интерфейсов станет слишком много, а функциональность — станет раздробленной.

Хороший дизайн системы — это в первую очередь простой дизайн. Чем меньше сущностей мы создаём для решения проблемы, тем выше вероятность, что дизайн хороший, поэтому следовать OCP необходимо с осторожностью.

**Может быть не нужен для маленьких приложений**

OCP нацелен на быстрое и дешёвое добавление функциональности и масштабирование системы. Он окупается, если система действительно большая, и проверять, как повлияло изменение кода, очень дорого или долго (или невозможно).

Если же приложение маленькое, то OCP может превратиться в принцип ради принципа — когда разработчики будут писать бойлерплейт-код для создания новых сущностей без видимой и ощутимой пользы.

OCP следует применять, если польза от него значительно выше, чем затраты от следования ему.


## <a name="liskov-substitution-principle"></a>Liskov Substitution Principle 

### Описание

Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP) вводит ограничения для иерархии объектов.

Звучит он так: функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Простыми словами — классы-наследники не должны противоречить базовому классу. Например, они не могут предоставлять интерфейс ýже базового. Поведение наследников должно быть ожидаемым для функций, которые используют базовый класс.

Немного удобнее думать об LSP в терминах «абстракция — реализация». Абстрактный класс или интерфейс играют роль базового типа, но вместе с этим — роль контракта на поведение.

Они гарантируют, что экземпляр любого конкретного класса будет содержать указанные поля и методы.

Это значит, что модуль, использующий этот абстрактный класс или интерфейс сможет работать с любой его реализацией.

### Коротко

Принцип подстановки Барбары Лисков:
- помогает проектировать систему, опираясь на поведение модулей;
- вводит ограничения и правила наследования объектов, чтобы их потомки не противоречили базовому поведению;
- делает поведение модулей последовательным и предсказуемым;
- помогает избегать дублирования, выделять общую для нескольких модулей функциональность в общий интерфейс;
- позволяет выявлять при проектировании проблемные абстракции и скрытые связи между сущностями.

### Шаблоны проектирования и приёмы рефакторинга

Главная цель принципа подстановки Лисков — «исключить сюрпризы» в поведении объектов. Достигать этой цели помогают некоторые методы и шаблоны проектирования и приёмы рефакторинга.

**Контрактное программирование**

Контрактное программирование — это метод проектирования, при котором проектировщики чётко определяют и формализуют спецификации отношений между объектами.

Спецификации могут описывать интерфейсы методов, их пред- и постусловия, описание проверок и критерии соответствия. Такие спецификации называются контрактами.

**Извлечение интерфейса, извлечение суперкласса**

В прошлых разделах мы выделяли общий интерфейс для классов, которые не вписывались в существующую иерархию.

Для подобной работы подходят приёмы извлечения интерфейса и извлечения суперкласса. В примере с иерархией пользователей мы использовали выделение суперкласса.

**Композиция, изменение модели наследования**

Среди создающих и структурных шаблонов можно условно выделить группу таких, которые используют композицию свойств и методов. Это, например, стратегия и декоратор, которые мы рассмотрели в разделе OCP.

Кроме них «исключить сюрпризы» помогает изменение модели наследования. Не всегда иерархия объектов в программной системе должна копировать иерархию их в реальном мире. ООП — про отношение между сущностями и их поведение, поэтому модель наследования должна зависеть именно от поведения объектов.

### Антипаттерны и запахи
Неправильная или неполная реализация некоторых шаблонов проектирования или приёмов, а также неправильная иерархия сущностей могут нарушить LSP.

**Непредсказуемое изменение поведения**

Для подобной задачи подходит шаблон Состояние — он позволяет менять поведение объектов в зависимости от их внутреннего состояния. Если он реализован правильно и полно, то LSP он не нарушит.

Допустим, мы делаем клон Медиума, где авторы будут публиковать статьи. Статья может находиться в разных состояниях, от которых зависит, что с ней можно делать. Например, удалённую статью нельзя удалить, а опубликованную — снова опубликовать.

**Интерфейс, которому нельзя доверять**

Более тонкое нарушение LSP — это «пустая» реализация интерфейса.

«Пустая» реализация интерфейса также нарушает принцип разделения интерфейса.

### Ограничения и подводные камни

Всем принципам приходится сталкиваться с реальностью, которая накладывает ограничения на их применение. Для LSP наиболее характерны дороговизна изменения модели иерархии, многословность контрактов, предел выделения суперкласса.

**Изменение иерархии дорого**

LSP помогает проектировать отношения между сущностями, учитывая возможные изменения в требованиях. Но вероятность спроектировать систему хорошо с первого раза — низкая.

Стремление следовать LSP может привести к изменению иерархии объектов в системе. Большие изменения в структурах — дороги, как по времени, так и по деньгам.

Также изменение структуры затрагивает большое количество компонентов. Если код плохо покрыт тестами, переписывание может привести к неработающему приложению.

**Использование контрактов ресурсозатратно**

Использование контрактов позволяет избежать усиления предусловий и ослабления постусловий. Однако, контракт увеличивает сложность проекта, а также увеличивает сроки разработки.

Покрытие методов контрактными спецификациями затратно по времени; контракты зачастую многословны и дублируют тесты. В некоторых случаях контракты снижают производительность кода.

**Выделение суперкласса имеет предел**

Выделение суперкласса позволяет избежать дублирования, но имеет предел вложенности. Невозможно выносить функциональность всё выше и выше без последствий — чрезмерное вынесение функциональности наверх может привести к появлению божественного объекта.

Также выделение суперкласса не гарантирует правильную иерархию объектов — может случиться, что новые бизнес-требования добавят сущность, которая не будет вписываться в уже изменённую иерархию.

## <a name="interface-segregation-principle"></a>Interface Segregation Principle 

### Описание

Сущности не должны зависеть от интерфейсов, которые они не используют.

Когда принцип нарушается, модули подвержены всем изменениям в интерфейсах, от которых они зависят. Это приводит к высокой связанности модулей друг с другом.

ISP помогает проектировать интерфейсы так, чтобы изменения затрагивали только те модули, на функциональность которых они действительно влияют. Чаще всего это заставляет интерфейсы дробить (разделять).

### Коротко
Принцип разделения интерфейса:
- помогает бороться с наследованием или реализацией ненужной функциональности;
- даёт возможность спроектировать модули так, чтобы их затрагивали изменения только тех интерфейсов, которые они действительно реализуют;
- снижает зацепление модулей;
- уничтожает наследование ради наследования, поощряет использование композиции;
- позволяет выявлять более высокие абстракции и находить неочевидные связи между сущностями.

### Шаблоны проектирования и приёмы рефакторинга

Следовать принципу разделения интерфейса помогают такие шаблоны проектирования как Адаптер, а также приёмы выделения интерфейса и множественного наследования.

**Адаптер**
Адаптер — шаблон проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

С точки зрения ISP этот шаблон помогает держать интерфейсы чистыми и понятными, а при необходимости совместить несовместимые модули через специальную прослойку (адаптер).

**Выделение интерфейса**

Выделение интерфейса — это приём, при котором одинаковые методы и поля выносят в отдельный интерфейс.

В качестве примера можно вернуться к Койну из прошлого раздела. Интерфейс Record — это выделенный общий интерфейс, который включает в себя общие для траты и дохода поля.

Выделение интерфейса тесно связано не только с ISP, но и с LSP. Например, оно используется при поиске корня композиции и как вспомогательный инструмент для выделения суперкласса.

**Множественное наследование**

Множественное наследование используется, например, чтобы реализовать функциональность нескольких интерфейсов.

В TypeScript такое наследование реализуется через миксины.

### Антипаттерны и запахи

Принцип разделения интерфейса концептуально похож на принцип единственной ответственности и решает схожие проблемы, только относящиеся к более высокому уровню абстракции.

**Грязный интерфейс**

Проблема грязного интерфейса возникает, когда интерфейс содержит в себе слишком много методов и полей. Как и большие модули в SRP, грязный интерфейс в ISP приводит к плохой читаемости и дорогой поддержке.

**«Пустая» реализация**

«Пустая» реализация интерфейса возникает, когда появляется модуль, которому не нужны все методы из реализуемого интерфейса.

ISP помогает проектировать интерфейсы, избегая проблем выше. Так при на основе большого интерфейса, мы бы могли выделить несколько интерфейсов с соответствующими ролями.

Тогда более простому классу достаточно было бы реализовать базовыый интерфейс. Более навороченный класс смог бы реализовать несколько интерфейсов одновременно с помощью множественного наследования.

### Ограничения и подводные камни
Как и в случае с SRP, проблемы с разделением интерфейсов возникают из трудностей проектирования и прогнозирования.

**Слепое следование опасно**

Слепое следование ISP грозит дроблению вообще всех интерфейсов на атомарные с одним методом или полем. Это похоже на атомарный CSS, когда каждое свойство описывается отдельным классом.

Но суть принципа не в том, чтобы раздробить интерфейсы, а в том, чтобы выделить минимально необходимое количество методов, чтобы реализующие его модули не зависели от ненужной функциональности.

**Как понять, что интерфейс стал грязным**

Во многих предметных областях сущности могут обладать очень большим количеством свойств и методов, из-за чего разделять интерфейсы может быть трудно. Разработчики могут столкнуться с ситуацией, когда не будет очевидно, в какой момент интерфейс всё ещё подчиняется ISP, а в какой — уже нет.

**Конфликты ролей и иерархий**

Интерфейсы можно условно поделить на роли: тип, поведение, ожидание (например в контракте) и др.

Иерархия ролей может конфликтовать с иерархией сущностей и модулей, которые реализуют интерфейсы. Это делает структуру системы сложной для понимания и может вводить в заблуждение при чтении кода.

## <a name="dependency-inversion-principle"></a>Dependency Inversion Principle

### Описание

Программные системы состоят из модулей, которые мы можем условно поделить на низкоуровневые и высокоуровневые.

Низкоуровневые содержат утилитарную функциональность: обращение к БД, запросы к серверу, рендеринг DOM-элементов на странице.

Высокоуровневые содержат сложную, более абстрактную бизнес-логику. Они достаточно абстрактны, чтобы их можно было переиспользовать в разных проектах: авторизация пользователей, валидация форм, отправка уведомлений.

В устойчивых системах высокоуровневые модули, как правило, не требуют обновления при изменении низкоуровневых. Добиться подобной устойчивости помогает принцип инверсии зависимостей.

Принцип инверсии зависимостей (Dependency Inversion Principle, DIP) предполагает, что:

Высокоуровневые модули не должны зависеть от низкоуровневых; оба типа должны зависеть от абстракций.
Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.
Таким образом DIP помогает снизить зацепление модулей (coupling).

Когда модули жёстко зацеплены, они слишком много знают друг о друге и не функционируют по отдельности. В такой ситуации изменения в одном будут требовать изменений в других — что нарушает OCP.

Зацепление (coupling) не стоит путать со связностью (cohesion).

Зацепление — степень взаимозависимости разных модулей. Чем выше зацепление, тем более хрупкой получается система, и тем сложнее вносить изменения.

Связность — степень, в которой задачи некоторого модуля, связаны друг с другом. Чем выше связность, тем строже модули следуют SRP, тем выше сфокусирован модуль на конкретной задаче.

Согласно принципу модули должны зависеть от других модулей не напрямую, а от абстракций.

DIP упрощает тестирование системы. Если модули зависят от интерфейсов, нам достаточно создать заглушку, реализующую этот интерфейс.

### Коротко
Принцип инверсии зависимостей:
- вводит правила и ограничения для зависимости одних модулей от других;
- снижает зацепление модулей;
- делает тестирование модулей проще;
- позволяет проектировать систему так, чтобы модули были заменяемы на другие.

### Шаблоны проектирования и приёмы рефакторинга

Следовать принципу инверсии зависимостей помогают инъекция зависимостей, наблюдатель и шаблонный метод.

**Инъекция зависимостей**

Внедрять зависимости можно тремя способами: через конструктор, через сеттеры и интерфейсно.

Самый простой вид инъекции — через конструктор. При создании класса в конструкторе мы перечисляем все зависимости, которые требуются для создания экземпляра.

Если зависимостей много, перечисление их всех в конструкторе может стать проблемой. Эту проблему частично решает инъекция через сеттер.

При таком внедрении каждая зависимость указывается в поле, которое можно изменить через set. 

Проблема этого подхода в том, что поля с зависимостями становятся public, что не всегда приемлемо.

Метод инъекции с помощью интерфейса похож на предыдущий, только в нём используются не сеттеры, а отдельные методы-инжекторы.

**Наблюдатель**

Наблюдатель — шаблон, который создаёт механизм подписки, когда некоторые сущности могут реагировать на поведение других.

Наблюдатель инвертирует контроль за выполнением программы схожим образом, как это делают обработчики событий в GUI. Обработчики событий вызываются в момент пользовательского события ввода: щелчок мыши, нажатие клавиши; наблюдатель — реагирует на изменение состояния наблюдаемого объекта.

**Шаблонный метод** 

Шаблонный метод — это шаблон, который определяет скелет алгоритма, а некоторые шаги даёт реализовывать подклассам. Так подклассы могут переопределять части алгоритма, не меняя общей структуры.

Конкретные классы реализуют абстрактные методы базового. Они также могут переопределить и некоторые методы по умолчанию. Как правило, конкретные переопределяют только часть функциональности.

В стандартной модели наследования потомки вызывают методы базового класса. Здесь же наоборот — методы, реализованные в конкретных классах, вызываются в базовом через шаблонный метод.

Преимущество такого подхода в повторном использовании алгоритма с различными вариациями. Опасность шаблона — в случайном нарушении LSP при изменении функциональности подкласса.

### Антипаттерны и запахи

Основная проблема антипаттернов и запахов ниже — в сокрытии зависимостей и увеличении зацепления модулей друг с другом.

**Контрол-фрик**

Контрол-фрик — это запах, при котором зависимости явно создаются в конструкторе с помощью new.

**Локатор служб**

Локатор служб — шаблон, который позволяет подключать зависимости в момент, когда они становятся нужны.

Мы называем его антипаттерном с оговоркой, что есть ситуации, когда он нужен — например, при работе с легаси. Но при создании новой системы лучше использовать DI.

Самый главный минус этого шаблона в том, что он нарушает инкапсуляцию, скрывая зависимости.

Понять код и предугадать его поведение становится трудно — ведь, чтобы узнать все зависимости необходимо изучить исходники. IDE уже не сможет подсказать, какие зависимости необходимы для создания класса.

При использовании DI такой проблемы нет — у нас просто не получится создать экземпляр класса, не передав все необходимые зависимости.

### Ограничения и подводные камни

Принцип инверсии зависимостей может приводить к ситуациям, когда поток управления программы задан неявно, а явное — лучше неявного.

**Неграмотное использование**

При неграмотном и бесконтрольном использовании принципа и IoC-контейнеров в частности логика взаимодействия компонентов может оказаться размазанной по разным частям приложения. Это мешает восприятию программы, снижает тестируемость и увеличивает стоимость внесения изменений.

Кроме того, не все зависимости стоят того, чтобы их инвертировать. Отличить такие от остальных бывает трудно из-за, например, специфики предметной области.

**Проблемы с DI**

С инъекцией зависимостей тоже могут возникать проблемы.

При инъекции через конструктор большое количество зависимостей сильно увеличивает конструктор. А при неграмотном использовании DI могут появиться циклические зависимости.

В обоих случаях стоит посмотреть в сторону SRP. Скорее всего, класс делает слишком много, и его надо разбивать на более мелкие.