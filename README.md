# SOLID

- [Single Responsibility Principle (SRP)](#single-responsibility-principle)
- [Open-Closed Principle (OCP)](#open-closed-principle)
- [Liskov Substitution Principle (LSP)](#liskov-substitution-principle)
- [Interface Segregation Principle (ISP)](#interface-segregation-principle)
- [Dependency Inversion Principle (DIP)](#dependency-inversion-principle)

## <a name="single-responsibility-principle"></a>Single Responsibility Principle  

### Описание
Принцип единственной ответственности (Single Responsibility Principle, SRP) означает, что у модуля должна быть только одна причина для изменения. Весь код, который меняется по этой причине, должен быть собран в этом модуле.

Проще говоря принцип предлагает нам проводить границы между модулями так, чтобы изменение в бизнес-правилах затрагивало как можно меньше модулей, в идеале — один.

Основной инструмент принципа — объединять те части, которые меняются по одной причине, и разделять те, которые меняются по разным.

Принцип позволяет уменьшить количество кода, который нужно менять при изменении бизнес-правил. Он помогает ограничить влияние этих изменений и контролировать сложность программы.

### Коротко
Принцип единственной ответственности:
- помогает разбивать и декомпозировать задачи по одной на модуль;
- уменьшает количество модулей, которые надо изменить при изменении требований;
- ограничивает влияние изменений, помогая контролировать сложность системы.

### Шаблоны проектирования и приёмы рефакторинга

**Выделение класса**

Выделение класса — приём рефакторинга, при котором из большого класса с множеством слабо-связанных по смыслу полей и методов, выделяется один или несколько классов.

Смысл приёма в том, чтобы явно выделить назначение класса. Идеальный результат — получить класс, который можно описать одной фразой или даже одним словом.

**Фасад**

Фасад — шаблон проектирования, при котором сложная логика скрывается за вызовом более простого API.

Фасад обеспечивает простое общение со сложной частью системы, беря ответственность за настройку и вызов специфических методов конкретных объектов на себя.

Один из минусов фасада в том, что он может превратиться в божественный объект.

**Прокси**

Прокси — шаблон проектирования, при котором общение с каким-то объектом контролирует другой объект-заместитель (прокси). Он позволяет расширять функциональность существующих классов, не меняя их.

### Антипаттерны и запахи
Существуют и антипаттерны, которые или сами нарушают SRP, или усложняют следование принципу.

**Божественный объект**

Божественный объект — это сущность, которая отвечает за слишком много.

Проблема таких объектов в том, что внутри них скапливается неоправданно большое количество данных. Со временем может случиться, что никакое действие нельзя будет сделать без участия божественного объекта.

Это затрудняет рефакторинг, тестирование и внесение изолированных изменений в код.

**Синглтон**

Синглтон — это паттерн, при котором в приложении существует только один экземпляр какого-то класса. Существующий синглтон гарантирует, что все новые созданные объекты будут ссылаться на него.

С точки зрения SRP это смешение ответственностей. Потому что синглтон не только выполняет свою основную функцию, но ещё и проверяет, не существует ли уже созданных экземпляров.

Проблем у этого паттерна несколько:
- он глобален — когда нарушается инкапсуляция состояния, повышается вероятность непредсказуемых нежелательных изменений;
- излишне имплицитен — трудно заранее понять, как себя поведёт объект в какой-то ситуации;
- трудно тестируется — глобальный объект хранит большое количество данных и может находиться в большом количестве различных состояний, из-за чего модульные тесты могут показывать непредсказуемые результаты.

**Смешение архитектурных слоёв**

Паттерн MVC подразумевает три сущности: модель, представление и контроллер. Модель отвечает за хранение данных; представление — за их отображение; контроллер — за преобразование и обработку.

Смешение слоёв — это неправильное распределение или размазывание ответственностей между слоями. Оно может приводить:
- к разрастанию контроллера, что делает его код трудным для понимания;
- появлению логики внутри модели, что затрудняет переиспользование модели.

### Ограничения и подводные камни
У каждого принципа есть ограничения и область применения. Для SRP характерны следующие ограничения и подводные камни.

**Слепое следование опасно**

Слепое следование принципу (например, преждевременная оптимизация) может создать лишние абстракции и сделать программу чрезмерно сложной. Использовать SRP стоит тогда, когда вносить изменения в класс, нарушающий его, становится дорого.

**Трудность начального проектирования**

Выделить зоны ответственности сущностей при первичном проектировании иногда бывает трудно. Взаимодействие сущностей может быть неочевидным, из-за чего проектировщикам может быть трудно определиться с методами классов. В этом случае могут помочь прототипирование и диаграммное моделирование (UML, DFD, ERD, IDEF).

**Разработка через тестирование — не панацея, а инструмент**

Считается, что разработка через тестирование (TDD) может помочь выделить в классах необходимые методы, но это тоже помогает не всегда. TDD определённо показывает, каким будет видеть наше API пользователь, но он не всегда помогает выделить зоны ответственности модулей.

## <a name="open-closed-principle"></a>Open-Closed Principle

### Описание

Принцип открытости-закрытости (Open-Closed Principle, OCP) помогает исключить такую проблему. Согласно ему модули должны быть открыты для расширения, но закрыты для изменения.

Простыми словами — модули надо проектировать так, чтобы их нельзя было менять, а новая функциональность должна появляться лишь с помощью создания новых сущностей и композиции их со старыми.

Основная цель принципа — помочь разработать проект, устойчивый к изменениям, срок жизни которых превышает срок существования первой версии проекта.

Модули, которые удовлетворяют OCP:

- открыты для расширения — их функциональность может быть дополнена с помощью других модулей, если изменятся требования;
- закрыты для изменения — расширение функциональности модуля не должно приводить к изменениям в модулях, которые его используют.

Конечно, всегда есть изменения, которые невозможно внести, не изменив код какого-то модуля — никакая система не может быть закрыта на 100%. Поэтому при проектировании важен стратегический подход. Необходимо определить, от каких именно изменений и какие именно модули вы хотите закрыть. Это решение следует принимать опираясь на опыт, а также знания предметной области и пользователей системы.

Нарушение принципа открытости-закрытости приводит к ситуациям, когда изменение в одном модуле вынуждает менять другие, связанные с ним. Это в свою очередь нарушает SRP, потому что весь код, который меняется по какой-то одной причине, должен быть собран в одном модуле. (Разные модули — разные причины для изменения.)

### Коротко
Принцип открытости-закрытости:
- заставляет проектировать модули так, чтобы они делали только одну вещь и делали её хорошо;
- побуждает связывать сущности через абстракции (а не реализацию) там, где могут поменяться бизнес-требования;
- обращает внимание проектировщиков на места стыка и взаимодействие сущностей;
- позволяет сократить количество кода, который необходимо менять при изменении бизнес-требований;
- делает внесение изменений безопасным и относительно дешёвым.

### Шаблоны проектирования и приёмы рефакторинга

**Абстрактная фабрика**

Фабрика — это сущность, которая создаёт другие сущности по заданным правилам, например, создаёт экземпляры классов или объекты.

Абстрактная фабрика — это фабрика, которая создаёт фабрики.

Этот шаблон позволяет создавать сущности без привязки к конкретным классам — то есть без привязки к реализации. Так добавление новых типов сущностей изменяет минимальное количество модулей.

**Стратегия**

В прошлом примере мы избавились от необходимости менять код форматеров при добавлении новых требований. Но вы могли заметить, что в методе configure класса AppConfigurator есть условие, которое проверяет тип формата для отчёта.

По-хорошему, подобные условия следует заменять на динамический выбор нужных сущностей. С этим может помочь ещё один шаблон — стратегия.

Этот шаблон позволяет менять настройки, конфигурацию или алгоритм в зависимости от ситуации и требований.

**Декоратор**

Декоратор — это шаблон, который заключается в создании обёрток с дополнительной функциональностью для объектов. Такие обёртки позволяют не изменять сам объект, но при этом расширять его функциональность.

Отличие декоратора от наследования в возможности расширять функциональность динамически, без необходимости описывать каждый класс-наследник отдельно.

**Наблюдатель**

Наблюдатель — шаблон, который создаёт механизм подписки, когда некоторые сущности могут реагировать на поведение других.

Этот шаблон позволяет добавлять новых наблюдателей без необходимости менять код наблюдаемого объекта.

**Замена прямого наследования на полиморфизм и композицию**

Модули, зависящие от конкретных классов, связаны с ними слишком сильно, из-за чего изменение в одном модуле затронет изменение в другом.

Замена прямого наследования на полиморфизм или композицию — это приём рефакторинга, который ослабляет зацепление модулей через введение абстракций: интерфейсов, обёрток и т. д.

### Антипаттерны и запахи
Все паттерны, которые так или иначе теснее связывают сущности между собой, можно назвать антипаттернами.

**Связывание через конкретные классы**

Проблемы связывания через конкретные классы мы рассмотрели в примере из раздела «В идеальном мире». Класс AreaCalculator изначально зависел от конкретного класса Rectangle, из-за чего при изменении требований, приходилось обновлять код этого класса.

Когда мы ввели прослойку в виде интерфейса Shape, класс AreaCalculator начинал зависеть от интерфейса, а не от конкретных классов, изменение в требованиях перестало затрагивать код класса AreaCalculator.

**Синглтон**

Синглтон — это паттерн, при котором в приложении существует только один экземпляр какого-то класса. Существующий синглтон гарантирует, что все новые созданные объекты будут ссылаться на него.

Если синглтон содержит в себе общее состояние или глобальные переменные, либо сам является глобальной сущностью, то зацепление объектов с ним чрезмерно высокое.

Это может приводить к ситуациям, когда при изменении требований приходится менять и сам синглтон, и все объекты, которые с ним связаны.

Синглтон можно использовать и без высокого зацепления модулей (применяя, например, абстрактные интерфейсы), но это значительно усложняет структуру проекта.

**Легковес**

Легковес — шаблон, который уменьшает расход памяти, держа общее состояние объектов внутри себя, вместо хранения одинаковых данных в каждом объекте.

Его проблема с точки зрения OCP в том же высоком связывании модулей. Если сущность выступает в роли общего контекста для нескольких объектов, при изменении требований придётся менять код каждого модуля.

Как и в случае с синглтоном, с легковесом можно работать без высокого зацепления, но это также будет увеличивать сложность.

### Ограничения и подводные камни

У каждого принципа есть ограничения и область применения. Для OCP характерны следующие ограничения и подводные камни.

**Система не может быть закрыта на 100%**

Всегда есть изменения, которые невозможно внести, не изменив код какого-то модуля, поэтому при проектировании важен стратегический подход. Необходимо определить, от каких именно изменений и какие именно модули вы хотите закрыть.

Следует учитывать, что люди очень плохо умеют прогнозировать изменения. Даже имея достаточно знаний о системе и опыта, проектировщики не могут быть уверены, что предусмотрели все возможные варианты развития системы.

OCP предлагает подход Just-in-time design, при котором новые сущности добавляются в систему по мере необходимости, но не раньше. Это чем-то похоже на отказ от ранней оптимизации и раннего добавления абстракций.

Цель подхода в том, чтобы не создавать абстракции на пустом месте. Один из критериев хорошего дизайна — простота, поэтому использовать OCP следует всегда с оглядкой на то, насколько система получится простой в итоге.

**Большое количество сущностей**

Добавление функциональности менее рискованно, чем изменение существующей, но взамен мы рискуем увеличить количество сущностей. Бесконтрольное и бездумное следование OCP может приводить к ситуациям, когда интерфейсов станет слишком много, а функциональность — станет раздробленной.

Хороший дизайн системы — это в первую очередь простой дизайн. Чем меньше сущностей мы создаём для решения проблемы, тем выше вероятность, что дизайн хороший, поэтому следовать OCP необходимо с осторожностью.

**Может быть не нужен для маленьких приложений**

OCP нацелен на быстрое и дешёвое добавление функциональности и масштабирование системы. Он окупается, если система действительно большая, и проверять, как повлияло изменение кода, очень дорого или долго (или невозможно).

Если же приложение маленькое, то OCP может превратиться в принцип ради принципа — когда разработчики будут писать бойлерплейт-код для создания новых сущностей без видимой и ощутимой пользы.

OCP следует применять, если польза от него значительно выше, чем затраты от следования ему.


## <a name="liskov-substitution-principle"></a>Liskov Substitution Principle 

## <a name="interface-segregation-principle"></a>Interface Segregation Principle 

## <a name="dependency-inversion-principle"></a>Dependency Inversion Principle