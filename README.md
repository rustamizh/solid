# SOLID

- [Single Responsibility Principle (SRP)](#single-responsibility-principle)
- [Open-Closed Principle (OCP)](#open-closed-principle)
- [Liskov Substitution Principle (LSP)](#liskov-substitution-principle)
- [Interface Segregation Principle (ISP)](#interface-segregation-principle)
- [Dependency Inversion Principle (DIP)](#dependency-inversion-principle)

## <a name="single-responsibility-principle"></a>Single Responsibility Principle  

### Описание
Принцип единственной ответственности (Single Responsibility Principle, SRP) означает, что у модуля должна быть только одна причина для изменения. Весь код, который меняется по этой причине, должен быть собран в этом модуле.

Проще говоря принцип предлагает нам проводить границы между модулями так, чтобы изменение в бизнес-правилах затрагивало как можно меньше модулей, в идеале — один.

Основной инструмент принципа — объединять те части, которые меняются по одной причине, и разделять те, которые меняются по разным.

Принцип позволяет уменьшить количество кода, который нужно менять при изменении бизнес-правил. Он помогает ограничить влияние этих изменений и контролировать сложность программы.

### Коротко
Принцип единственной ответственности:
- помогает разбивать и декомпозировать задачи по одной на модуль;
- уменьшает количество модулей, которые надо изменить при изменении требований;
- ограничивает влияние изменений, помогая контролировать сложность системы.

### Шаблоны проектирования и приёмы рефакторинга

**Выделение класса**

Выделение класса — приём рефакторинга, при котором из большого класса с множеством слабо-связанных по смыслу полей и методов, выделяется один или несколько классов.

Смысл приёма в том, чтобы явно выделить назначение класса. Идеальный результат — получить класс, который можно описать одной фразой или даже одним словом.

**Фасад**

Фасад — шаблон проектирования, при котором сложная логика скрывается за вызовом более простого API.

Фасад обеспечивает простое общение со сложной частью системы, беря ответственность за настройку и вызов специфических методов конкретных объектов на себя.

Один из минусов фасада в том, что он может превратиться в божественный объект.

**Прокси**

Прокси — шаблон проектирования, при котором общение с каким-то объектом контролирует другой объект-заместитель (прокси). Он позволяет расширять функциональность существующих классов, не меняя их.

### Антипаттерны и запахи
Существуют и антипаттерны, которые или сами нарушают SRP, или усложняют следование принципу.

**Божественный объект**

Божественный объект — это сущность, которая отвечает за слишком много.

Проблема таких объектов в том, что внутри них скапливается неоправданно большое количество данных. Со временем может случиться, что никакое действие нельзя будет сделать без участия божественного объекта.

Это затрудняет рефакторинг, тестирование и внесение изолированных изменений в код.

**Синглтон**

Синглтон — это паттерн, при котором в приложении существует только один экземпляр какого-то класса. Существующий синглтон гарантирует, что все новые созданные объекты будут ссылаться на него.

С точки зрения SRP это смешение ответственностей. Потому что синглтон не только выполняет свою основную функцию, но ещё и проверяет, не существует ли уже созданных экземпляров.

Проблем у этого паттерна несколько:
- он глобален — когда нарушается инкапсуляция состояния, повышается вероятность непредсказуемых нежелательных изменений;
- излишне имплицитен — трудно заранее понять, как себя поведёт объект в какой-то ситуации;
- трудно тестируется — глобальный объект хранит большое количество данных и может находиться в большом количестве различных состояний, из-за чего модульные тесты могут показывать непредсказуемые результаты.

**Смешение архитектурных слоёв**

Паттерн MVC подразумевает три сущности: модель, представление и контроллер. Модель отвечает за хранение данных; представление — за их отображение; контроллер — за преобразование и обработку.

Смешение слоёв — это неправильное распределение или размазывание ответственностей между слоями. Оно может приводить:
- к разрастанию контроллера, что делает его код трудным для понимания;
- появлению логики внутри модели, что затрудняет переиспользование модели.

### Ограничения и подводные камни
У каждого принципа есть ограничения и область применения. Для SRP характерны следующие ограничения и подводные камни.

**Слепое следование опасно**

Слепое следование принципу (например, преждевременная оптимизация) может создать лишние абстракции и сделать программу чрезмерно сложной. Использовать SRP стоит тогда, когда вносить изменения в класс, нарушающий его, становится дорого.

**Трудность начального проектирования**

Выделить зоны ответственности сущностей при первичном проектировании иногда бывает трудно. Взаимодействие сущностей может быть неочевидным, из-за чего проектировщикам может быть трудно определиться с методами классов. В этом случае могут помочь прототипирование и диаграммное моделирование (UML, DFD, ERD, IDEF).

**Разработка через тестирование — не панацея, а инструмент**

Считается, что разработка через тестирование (TDD) может помочь выделить в классах необходимые методы, но это тоже помогает не всегда. TDD определённо показывает, каким будет видеть наше API пользователь, но он не всегда помогает выделить зоны ответственности модулей.

## <a name="open-closed-principle"></a>Open-Closed Principle  

## <a name="liskov-substitution-principle"></a>Liskov Substitution Principle 

## <a name="interface-segregation-principle"></a>Interface Segregation Principle 

## <a name="dependency-inversion-principle"></a>Dependency Inversion Principle